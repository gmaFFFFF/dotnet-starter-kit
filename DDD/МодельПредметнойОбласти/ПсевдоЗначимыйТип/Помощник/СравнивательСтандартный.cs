using static gmafffff.СтартовыйНабор.DDD.МодельПредметнойОбласти.Помощник.Сравниватель_Помощник;

namespace gmafffff.СтартовыйНабор.DDD.МодельПредметнойОбласти.Помощник;

/// <summary>
///     Вспомогательный класс для реализации интерфейсов <see cref="IEquatable{T}" />, <see cref="IComparable{T}" />,
///     <see cref="IComparable" /> класса <see cref="ПсевдоЗначимыйТип" />
/// </summary>
/// <remarks>
///     Создание объекта необходимо осуществлять через статический член <see cref="Сравниватель" />
/// </remarks>
public class СравнивательСтандартный : IComparer, IComparer<ПсевдоЗначимыйТип> {
    /// <summary>
    ///     Свойство для получения объекта-сравнивателя
    /// </summary>
    /// <remarks>
    ///     Строки сравниваются без учета регистра, см. <see cref="StringComparison.CurrentCultureIgnoreCase" />
    /// </remarks>
    public static СравнивательСтандартный Сравниватель =>
        _сравнивательКэш ??= new СравнивательСтандартный(
            new ЧитателиАтрибутов_Хранилище(new[] { typeof(ПсевдоЗначимыйТип) }.ToHashSet()));


    /// <summary>
    ///     Метод сравнения объектов по значению
    /// </summary>
    /// <param name="x">Сравниваемый объект № 1</param>
    /// <param name="y">Сравниваемый объект № 2</param>
    /// <returns>
    ///     -1 - объект <paramref name="x" /> меньше <paramref name="y" />
    ///     0 - объект <paramref name="x" /> равен  <paramref name="y" />
    ///     1 - объект <paramref name="x" /> больше <paramref name="y" />
    /// </returns>
    [Pure]
    public Result<short> Сравнить(object? x, object? y) {
        var результат = Сравнить(x, y);
        if (результат.IsFailed) return результат;

        // Проверка постусловий
        Debug.Assert(!(x?.GetType() != y?.GetType() && результат.Value == 0)
            , "Объекты разных типов не могут быть одинаковыми");

        return результат;

        Result<short> Сравнить(object? x, object? y) {
            // Сравниваем по ссылке
            if (СравнитьПоСсылке(x, y) is { } сравСсылок)
                return Result.Ok(сравСсылок)
                    .WithSuccess(new Success(_сообщениеУспешногоСравнения)
                        .WithMetadata(nameof(СравнениеТип), СравнениеТип.Ссылка));

            //Сравниваем по значению
            var сравЗнач = НайдиПервогоОбщегоПредка(x!.GetType(), y!.GetType())
                .Преобразуй(тип => _хранилище.ДайСчитывателиЗначений(тип))
                .Преобразуй(читатели => читатели.Where(читатель =>
                    !читатель.Attributes.Any(attr => attr is ПсевдоЗначимыйТип.НеСравниватьПоAttribute)))
                .Преобразуй(читатели => СравнитьОбъектыПоЗначениямАтрибутов(x, y, читатели, _типСравненияСтрок));
            if (сравЗнач.IsSuccess && сравЗнач is { Value: > 0 or < 0 })
                return сравЗнач.WithSuccess(new Success(_сообщениеУспешногоСравнения)
                    .WithMetadata(nameof(СравнениеТип), СравнениеТип.Значение));

            //Сравниваем по типу
            var сравТип = СравнитьПоТипу(x, y);
            if (сравТип.IsSuccess)
                return сравТип.WithSuccess(new Success(_сообщениеУспешногоСравнения)
                    .WithMetadata(nameof(СравнениеТип), СравнениеТип.Тип));
            // Возврат к результату сравнения по значению
            if (сравЗнач.IsSuccess)
                return сравЗнач.WithSuccess(new Success(_сообщениеУспешногоСравнения)
                    .WithMetadata(nameof(СравнениеТип), СравнениеТип.Значение));

            // Возвращаем ошибки
            return Result.Merge(сравЗнач.ToResult(), сравТип.ToResult());
        }
    }

    /// <summary>
    ///     Рассчитывает хэш-код объекта на основе значения его атрибутов
    /// </summary>
    /// <param name="псевдоЗначимыйТип">Объект, у которого необходимо вычислить хэш-код</param>
    /// <returns>Хэш-код</returns>
    [Pure]
    public int РассчитайХэшКод(ПсевдоЗначимыйТип псевдоЗначимыйТип) {
        //TODO: сделать контроллируемую глубину расчета хэша в списках?
        // Стандарнтый хэш по атрибутам класса
        if (псевдоЗначимыйТип.КомпонентыСравненияПользовательские is null)
            return Сравниватель_Помощник.РассчитайХэшКод(псевдоЗначимыйТип
                , _хранилище.ДайСчитывателиЗначений(псевдоЗначимыйТип.GetType()).Value
                , _типСравненияСтрок);

        // Хэш по пользовательским данным
        var пользовательскийАтрибут = nameof(ПсевдоЗначимыйТип.КомпонентыСравненияПользовательские);
        var считыватель = _хранилище.ДайСчитывателиЗначений(typeof(ПсевдоЗначимыйТип))
            .Value
            .Where(читатель => читатель.ИмяАтрибута == пользовательскийАтрибут);
        return Сравниватель_Помощник.РассчитайХэшКод(псевдоЗначимыйТип
            , считыватель
            , _типСравненияСтрок);
    }

    #region Частные члены

    private enum СравнениеТип {
        Ссылка,
        Значение,
        Тип
    }

    private const string _сообщениеУспешногоСравнения = "Сравнить объекты удалось";

    private static СравнивательСтандартный? _сравнивательКэш;

    protected ЧитателиАтрибутов_Хранилище _хранилище;

    protected StringComparison _типСравненияСтрок;

    protected СравнивательСтандартный(ЧитателиАтрибутов_Хранилище хранилище,
        StringComparison типСравненияСтрок = StringComparison.CurrentCultureIgnoreCase) {
        _хранилище = хранилище;
        _типСравненияСтрок = типСравненияСтрок;
    }

    #endregion

    #region Реализация интерфейса IComparer, IComparer<ПсевдоЗначимыйТип>

    [Pure]
    int IComparer.Compare(object? x, object? y) {
        if (x is ПсевдоЗначимыйТип а1 && y is ПсевдоЗначимыйТип а2)
            return ((IComparer<ПсевдоЗначимыйТип>)this).Compare(а1, а2);

        var результат = Сравнить(x, y);
        результат.Или(new Action(() => throw new ArgumentException(
            string.Join("\n", результат.Errors.Select(ошибка => ошибка.Message)))));

        return результат.Value;
    }

    [Pure]
    int IComparer<ПсевдоЗначимыйТип>.Compare(ПсевдоЗначимыйТип? x, ПсевдоЗначимыйТип? y) {
        var результат = Сравнить(x, y);

        // Сравниваем по ссылке
        var удалосьСравнитьПоСсылкеЛи =
            результат.IsSuccess && результат.Successes.Any(success =>
                success.HasMetadata(nameof(СравнениеТип),
                    o => o is СравнениеТип.Ссылка));
        if (удалосьСравнитьПоСсылкеЛи)
            return результат.Value;

        // Сравниваем по пользовательским данным
        if (x!.GetType() == y!.GetType()
            && x.КомпонентыСравненияПользовательские is not null
            && y.КомпонентыСравненияПользовательские is not null) {
            const string пользовательскийАтрибут = nameof(ПсевдоЗначимыйТип.КомпонентыСравненияПользовательские);
            var считыватель = ДайСчитывателиПубличныхАтрибутовЭкземпляра(typeof(ПсевдоЗначимыйТип))
                .Value
                .Where(читатель => читатель.ИмяАтрибута == пользовательскийАтрибут);
            var сравЗнач = СравнитьОбъектыПоЗначениямАтрибутов(x, y, считыватель, _типСравненияСтрок);
            if (сравЗнач.IsSuccess)
                return сравЗнач.Value;
        }

        результат.Или(new Action(() => throw new ArgumentException(
            string.Join("\n", результат.Errors.ToString()))));

        return результат.Value;
    }

    #endregion
}